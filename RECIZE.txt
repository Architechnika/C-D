//Базовый класс в иерархии классов View
function GraphicView(elements, backX, backY, backW, backH, fillCol) {
    //Массив графических обьектов
    this.elems = elements;
    //Обьект заднего фона
    this.backGround = game.newRectObject({
        x: backX,
        y: backY,
        w: backW,
        h: backH,
        fillColor: fillCol
    });
    var bgX = this.backGround.x;
    var bgY = this.backGround.y;
    var bgW = this.backGround.w;
    var bgH = this.backGround.h;
    var midItem = this.elems[(Math.floor(this.elems.length / 2))].getImageObject();
    var midBGX = (this.backGround.x + this.backGround.w) / 2
    var midBGY = (this.backGround.y + this.backGround.h) / 2
    var a;
    var b;

    this.getBackGround = function () {
        return this.backGround;
    }

    //Смещает все объекты objects на shiftX и shiftY
    this.elementsMove = function (shiftX, shiftY, isRemember) {
        var bX = this.backGround.x;
        var bY = this.backGround.y;
        var bW = this.backGround.w;
        var bH = this.backGround.h;

        var iEF = !this.elems[0].move ? this.elems[0].getImageObject() : this.elems[0];
        var iEL = !this.elems[this.elems.length - 1].move ? this.elems[this.elems.length - 1].getImageObject() : this.elems[this.elems.length - 1];
        //Проверяем, выходят ли крайние элементы поля за пределы поля
        if ((iEL.x <= bX && iEL.y <= bY) || (iEF.x + iEF.w >= bX + bW && iEF.y + iEF.h >= bY + bH)) {
            if (iEL.x + shiftX > bX)
                shiftX = bX - iEL.x;
            else if (iEF.x + iEF.w + shiftX < bX + bW)
                shiftX = (bX + bW) - (iEF.x + iEF.w);
            if (iEL.y + shiftY > bY)
                shiftY = bY - iEL.y;
            else if (iEF.y + iEF.h + shiftY < bY + bH)
                shiftY = (bY + bH) - (iEF.y + iEF.h);
            //Cмещаем все элементы
            OOP.forArr(this.elems, function (el) {
                if (!el.move) {
                    el = el.getImageObject();
                }
                el.move(new point(shiftX, shiftY));
            });
            if (!isRemember) {
                a = (midItem.getPositionC().x - midBGX) + shiftX;
                b = (midItem.getPositionC().y - midBGY) + shiftY;
            }
        }
    }
    //Ресайзит this.elemens на величину delta
    this.resizeView = function (delta, x, y) {
        if (delta < 0) {
            if (zoom > totalWidth * 3)
                return;
            zoom++;
        } else {
            if (zoom <= 1)
                return;
            zoom--;
        }
        bgW -= delta;
        bgH -= delta;
        // if(this.backGround.x >= bgX)
        bgX += (delta / 2);
        // if(this.backGround.y >= bgY)
        bgY += (delta / 2);
        log(bgX)
        var itemWH = bgW / totalWidth;
        var iter = 0;
        var startX = bgX;
        var startY = bgY;
        OOP.forArr(this.elems, function (el, i) {
            var item = el.getImageObject();
            item.w = itemWH;
            item.h = itemWH;
            item.x = startX;
            item.y = startY;

            if (iter == totalWidth - 1) {
                iter = 0;
                startX = bgX;
                startY += itemWH;

            } else {
                startX += itemWH;
                iter++;
            }
        });
        this.elementsMove(a, b, true);
    }

    //Проверяет, находятся ли объекты objs внутри квадрата области полностью. Если она за пределами - setVisible(false)
    this.checkObjsInArea = function () {
        //  this.backGround.draw();
        var bg = this.backGround;
        var arr = [];
        var arr1 = []
        OOP.forArr(this.elems, function (el) {
            if (bg !== undefined) {
                var itm = el.getImageObject ? el.getImageObject() : el;
                /* if ((itm.getPosition().x < bg.x) || (itm.getPosition().y < bg.y) || (itm.getPosition().x + itm.getPosition().w > (bg.x + bg.w)) || (itm.getPosition().y + itm.getPosition().h > (bg.y + bg.h)))
                     itm.transparent(-0.01)
                 else itm.transparent(0.5)*/
                if (itm.getAlpha() == 0)
                    itm.setVisible(false)
                else itm.setVisible(true)
            }
        });
    }
}